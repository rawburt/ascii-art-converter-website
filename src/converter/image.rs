//! Image to ASCII converter.
//!
//! This module is responsible for converting images to ASCII. It uses the [image] crate to
//! read the PNG.
//!
//! Robert Peterson and Kelsey Werner 2023

use crate::converter::{dimension::Dimension, symbol_map::symbol_for_brightness, ConvertError};
use image::{imageops, io::Reader, ImageBuffer, Luma};
use std::io::{BufRead, Read, Seek};

/// The max image size in pixels.
///
/// This is used to scale images down in order to create ASCII art that is no larger
/// than 200x200 characters.
const MAX_ASCII_DIMENSION: u32 = 200;

/// Convert a [ImageBuffer] into an ASCII [String].
///
/// ASCII is generated by looking at each pixel of the image. To generate ASCII of reasonable
/// size, the image is first scaled down if it is too big. The [image] crate is used to scale
/// the image and to iterate over each pixel of the image.
fn convert_image_to_ascii(img: ImageBuffer<Luma<u8>, Vec<u8>>) -> String {
    let mut dimension = Dimension::from(img.dimensions());

    dimension.scale_down(MAX_ASCII_DIMENSION);

    let newimg = imageops::resize(
        &img,
        dimension.width,
        dimension.height,
        imageops::FilterType::Triangle,
    );

    // generate ascii
    let mut ascii: String = Default::default();

    for y in 0..dimension.height {
        // Skip vertical pixels half the time to account for typefaces making
        // the ascii much taller than wider in relation to the original image:
        // http://paulbourke.net/dataformats/asciiart/
        if y % 2 == 0 {
            continue;
        }
        for x in 0..dimension.width {
            let p = *newimg.get_pixel(x, y);
            let brightness: u8 = p[0];
            let symbol = symbol_for_brightness(brightness);
            ascii.push(symbol);
        }
        ascii.push('\n');
    }

    ascii
}

/// [AsciiImageBuffer] is a trait that represents a buffer that implements
/// the [Read], [Seek], and [BufRead] traits. This trait is used as a trait alias.
///
/// The idea to make a new trait to be used as a trait alias comes from StackOverflow:
/// <https://stackoverflow.com/questions/26070559/is-there-any-way-to-create-a-type-alias-for-multiple-traits>
pub trait AsciiImageBuffer: Read + Seek + BufRead {}
impl<T: Read + Seek + BufRead> AsciiImageBuffer for T {}

/// [Image] is a struct that holds the [AsciiImageBuffer] that will be turned into an ASCII [String].
pub struct Image<'a, T>
where
    T: AsciiImageBuffer,
{
    /// A reference to the image that will be turned into an ASCII.
    file: &'a mut T,
}

impl<'a, T> Image<'a, T>
where
    T: AsciiImageBuffer,
{
    /// Create a new [Image].
    pub fn new(file: &'a mut T) -> Image<'a, T> {
        Image { file }
    }

    /// Convert a [Image] to an ASCII [String].
    ///
    /// The [image] crate is used to parse the image into a readable buffer.
    pub fn convert_to_ascii(&mut self) -> Result<String, ConvertError> {
        match Reader::new(&mut self.file).with_guessed_format() {
            Ok(image_with_format) => match image_with_format.decode() {
                Ok(img) => Ok(convert_image_to_ascii(img.into_luma8())),
                Err(_) => Err(ConvertError::DecodeError),
            },
            Err(_) => Err(ConvertError::ReadError),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::{
        fs,
        fs::File,
        io::{BufReader, Cursor, Error, ErrorKind, SeekFrom},
    };

    // I was trying to figure out how to make [Seek] fail in order to raise an error
    // when I call `.with_guessed_format()` inside of the `.convert_to_ascii()` function.
    // I looked around for ways to utilize dependency injection of some sort, and I found
    // this StackOverflow comment:
    // https://stackoverflow.com/questions/72817819/how-do-i-use-rust-traits-to-abstract-http-call-for-tests
    //
    // The comment helped me realize that I can implement the [AsciiImageBuffer] trait requirements
    // in a way that makes them fail every time they are called. And that's exactly what I did for
    // the [BadImage] struct and the traits it implements.
    struct BadImage;

    impl Seek for BadImage {
        fn seek(&mut self, _pos: SeekFrom) -> std::io::Result<u64> {
            Err(Error::new(ErrorKind::Other, "Bad Seek.seek!"))
        }
    }

    impl Read for BadImage {
        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {
            Err(Error::new(ErrorKind::Other, "Bad Read.read!"))
        }
    }

    impl BufRead for BadImage {
        fn fill_buf(&mut self) -> std::io::Result<&[u8]> {
            Err(Error::new(ErrorKind::Other, "Bad BufRead.fill_buf!"))
        }

        fn consume(&mut self, _amt: usize) {}
    }

    // Test the [ConvertError::ReadError] failure state of `convert_to_ascii()`.
    #[test]
    fn test_read_error() {
        let mut bad_image = BadImage;
        let mut img = Image::new(&mut bad_image);

        assert_eq!(img.convert_to_ascii(), Err(ConvertError::ReadError));
    }

    // Test the [ConvertError::DecodeError] failure state of `convert_to_ascii()`.
    #[test]
    fn test_decode_error() {
        let mut buff = Cursor::new(String::new());
        let mut img = Image::new(&mut buff);

        assert_eq!(img.convert_to_ascii(), Err(ConvertError::DecodeError));
    }

    // Test the successful conversion of an image into ASCII.
    #[test]
    fn test_convert_to_ascii() {
        // The idea to use "CARGO_MANIFEST_DIR" comes from StackOverflow:
        // https://stackoverflow.com/questions/30003921/how-can-i-locate-resources-for-testing-with-cargo
        let img_path = concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_assets/images/freakazoid-small.png"
        );
        let img_file = File::open(img_path).unwrap();
        let mut img_reader = BufReader::new(img_file);
        let mut img = Image::new(&mut img_reader);
        let ascii = img.convert_to_ascii();

        assert!(ascii.is_ok());

        let ascii = ascii.unwrap();

        // The idea to use "CARGO_MANIFEST_DIR" comes from StackOverflow:
        // https://stackoverflow.com/questions/30003921/how-can-i-locate-resources-for-testing-with-cargo
        let ascii_path = concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_assets/ascii/freakazoid-small.txt"
        );
        let ascii_file =
            fs::read_to_string(ascii_path).expect("Should have been able to read ASCII file.");

        assert_eq!(ascii, ascii_file);
    }
}
